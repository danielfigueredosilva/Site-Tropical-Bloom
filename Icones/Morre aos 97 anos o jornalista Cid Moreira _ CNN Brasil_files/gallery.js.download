const galleries = document.querySelectorAll('.gallery');

// Adiciona um ouvinte de evento de clique em todas as galerias
galleries.forEach((gallery) => {
    gallery.addEventListener('click', (e) => {
        const target = e.target;

        // Verifica se houve uma mudança de seleção de rádio (quando troca a imagem grande)
        if (target.matches('.gallery__selector')) {
            switchGridToFull(target);
        }

        // Verifica se o clique foi feito no modal
        if (target.matches('.gallery__modal')) {
            switchToDefault(target);
        }

        // Executa as funções abaixo quando houver qualquer interação na galeria
        handleThumbnails(target);
        handleScroll(target);
    });

    // Executa thumbnailScroll após o carregamento inicial da galeria (Onload)
    thumbnailScroll(gallery);
})

// Executa após o carregamento da página se existir alguma galeria
if (galleries.length > 0) {
    // Captura as teclas pressionadas e muda o conteúdo principal das galerias
    document.addEventListener('keydown', handleKeyDown);

    // Eventos de toque (swipe)
    document.addEventListener('touchstart', handleSwipe);
    document.addEventListener('touchend', handleSwipe);
}

// Retorna do modo grid para o modo full
function switchGridToFull(target) {
    const gallery = target.closest('.gallery');
    const radioGrid = gallery.querySelector('.gallery__layout--grid');
    const radioFull = gallery.querySelector('.gallery__layout--full');

    if (radioGrid.checked) {
        radioFull.checked = true;
    }
}

// Retorna do modo grid para o modo full
function switchToDefault(target) {
    const gallery = target.closest('.gallery');
    const radioDefault = gallery.querySelector('.gallery__layout--default');
    const radioGrid = gallery.querySelector('.gallery__layout--grid');
    const radioFull = gallery.querySelector('.gallery__layout--full');

    if (radioGrid.checked || radioFull.checked) {
        radioDefault.checked = true;
    }
}

// Manipula o scroll
function handleScroll(target) {
    const gallery = target.closest('.gallery');
    const layout = gallery?.querySelector('.gallery__layout:checked');
    const needScroll = ['gallery__layout--full', 'gallery__layout--grid'];

    if (layout) {
        const matchingClasses = needScroll.filter(className => layout.classList.contains(className));

        if (matchingClasses.length > 0) {
            blockScroll(true);
        } else {
            blockScroll(false);
        }
    } else {
        blockScroll(false);
    }
}

// Bloqueia o scroll
function blockScroll(shouldBlock = true) {
    const body = document.querySelector('body');
    const html = document.documentElement;

    body.style.overflow = shouldBlock ? 'hidden' : '';
    html.style.overflow = shouldBlock ? 'hidden' : '';
    body.style.touchAction = shouldBlock ? 'none' : '';
    html.style.touchAction = shouldBlock ? 'none' : '';
}

// Manipula as thumbnails
function handleThumbnails(target) {
    const gallery = target.closest('.gallery');
    const classActive = 'gallery__thumb--active';
    const newThumb = gallery.querySelector(`.gallery__thumb label[for="${target.id}"]`)?.parentElement;
    const oldThumb = gallery.querySelector(`.${classActive}`);

    // Ativa a nova thumbnail e executa o scroll
    if (newThumb && oldThumb) {
        oldThumb.classList.remove('gallery__thumb--active');
        newThumb.classList.add('gallery__thumb--active');
    }

    thumbnailScroll(gallery);
}

// Faz o scroll das thumbnails
function thumbnailScroll(gallery) {
    const galleryWidth = gallery.offsetWidth;
    const thumbnails = gallery.querySelector('.gallery__thumb-list');
    const thumbWidth = gallery.querySelector('.gallery__thumb').offsetWidth;
    const gapWidth = 2;
    const stepWidth = thumbWidth + gapWidth;
    const activeThumb = gallery.querySelector('.gallery__thumb--active');
    const activeIndex = Array.from(thumbnails.children).indexOf(activeThumb);
    const hiddenThumbOffset = 40;
    const scrollDistance = activeIndex * stepWidth - (galleryWidth - thumbWidth) + hiddenThumbOffset;

    thumbnails.scrollTo({
        left: scrollDistance,
        behavior: 'smooth'
    });
}

// Troca a imagem principal da galeria ao pressionar uma tecla específica
function handleKeyDown(event) {
    const keyCode = event.code;
    const buttonSelectors = {
        ArrowLeft: '.gallery__selector:checked + .gallery__item .gallery__button--prev',
        ArrowRight: '.gallery__selector:checked + .gallery__item .gallery__button--next'
    };
    const selector = buttonSelectors[keyCode];

    if (selector) {
        const buttons = document.querySelectorAll(selector);
        buttons.forEach(button => {

            // Verifica se existe um botão de anúncio
            if (button.classList.contains('gallery__button--ad')) {
                const gallery = button.closest('.gallery');
                const layout = gallery?.querySelector('.gallery__layout:checked');

                // Usa botões sem anúncio se não estiver no layout default
                if (layout && !layout.classList.contains('gallery__layout--default')) {

                    if (button.classList.contains('gallery__button--next')) {
                        button = button.closest('.gallery__button--next:not(.gallery__button--ad)');
                    }

                    if (button.classList.contains('gallery__button--prev')) {
                        button = button.closest('.gallery__button--prev:not(.gallery__button--ad)');
                    }
                }
            }

            button.click();
        });
    }

    if (keyCode === 'Escape') {
        const galleries = document.querySelectorAll('.gallery');

        galleries.forEach(gallery => {
            const galleryDefault = gallery.querySelector('.gallery__layout--default');

            if (!galleryDefault.checked) {
                galleryDefault.click();
            }
        });
    }
}

// SWIPE
let touchStartX = 0;
let touchEndX = 0;
const swipeThreshold = 50; // Limite de movimento para considerar como um "swipe"

// Determina a direção do "swipe" e executa a ação correspondente
function handleSwipe() {
    const type = event.type;
    const target = event.target;
    const gallery = target.closest('.gallery');
    const layout = gallery?.querySelector('.gallery__layout:checked') || false;
    const layoutDefault = layout?.classList?.contains('gallery__layout--default') ?? false;
    const touchX = event.changedTouches[0].clientX;

    if (type === 'touchstart') {
        touchStartX = touchX;
    } else if (type === 'touchend') {
        touchEndX = touchX;

        const distance = touchEndX - touchStartX;
        if (Math.abs(distance) >= swipeThreshold) {
            const galleryItem = target?.closest('.gallery__item');
            const direction = (distance > 0) ? 'prev' : 'next';
            const button = '.gallery__button';
            const adSelector = `${button}--${direction}${button}--ad`;
            const defaultSelector = `${button}--${direction}`;

            const navItem = layoutDefault
                ? (galleryItem?.querySelector(adSelector) || galleryItem?.querySelector(defaultSelector))
                : galleryItem?.querySelector(defaultSelector);

            if (navItem) {
                navItem.click();
            }
        }
    }
}
